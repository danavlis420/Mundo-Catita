Buenas. Estoy trabajando en un juego WEB SANDBOX, que se trata de un mundo isométrico frontal, donde tendremos la posibilidad de manejar un personaje o dejar que se maneje solo, pintar tiles, para crear construcciones o añadir objetos y que interactuen con ellos. Todo está en html, css y javascript. Los mundos pueden ser exportados en un archivo .json y los tiles son imagenes en una carpeta, pudiendo así añadirse más, ya que son leídos en un archivo .json generado a través de un script de node. Actualmente el proyecto tiene el motor básico, grilla, un placeholder de personaje, el script para cargar tiles. Te compartiré los archivos en su estado actual, quiero que guardes todo en tu memoria para que podamos comenzar con el desarrollo. la jerarquía es MAIN > /Assets/sprites.json - scripts/camera.js, config.js, generateSprites.js, grid.js, hud.js, main.js, player.js - index.html - README.md - script.js - style.css - todo.md


Aquí los script más relevantes:

//script.js
/*
Mundo Catita - script.js (vista isométrica frontal)
- Grilla isométrica como suelo
- Personaje y objetos dibujados de frente
- Movimiento libre diagonal con snap suavizado a la grilla
*/

const CONFIG = {
  cols: 20,
  rows: 20,
  tileWidth: 64,
  tileHeight: 32,
  scale: 1.0,
  backgroundColor: '#2b3440',
  playerSpritePath: 'assets/sprites/player.png',
  initialPlayer: { x: 10, y: 10 },
  cameraLag: 0.12,
  playerSpeed: 5,     // tiles por segundo
  snapSpeed: 10       // velocidad de snap a grilla
};

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

const state = {
  cols: CONFIG.cols,
  rows: CONFIG.rows,
  tileW: CONFIG.tileWidth,
  tileH: CONFIG.tileHeight,
  scale: CONFIG.scale,
  camera: { x: 0, y: 0 },
  cameraTarget: { x: 0, y: 0 },
  player: { x: CONFIG.initialPlayer.x, y: CONFIG.initialPlayer.y, targetX: CONFIG.initialPlayer.x, targetY: CONFIG.initialPlayer.y },
  keys: {},
  sprite: null,
  spriteLoaded: false
};

const playerImage = new Image();
playerImage.src = CONFIG.playerSpritePath;
playerImage.onload = () => state.spriteLoaded = true;

// ----------------- DIBUJO -----------------
function clear() {
  ctx.fillStyle = CONFIG.backgroundColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function tileToScreen(x, y) {
  const screenX = (x - y) * (state.tileW / 2);
  const screenY = (x + y) * (state.tileH / 2);
  return { x: screenX, y: screenY };
}

function drawIsometricGrid() {
  ctx.save();
  ctx.translate(canvas.width / 2 - state.camera.x, canvas.height / 4 - state.camera.y);
  ctx.scale(state.scale, state.scale);

  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;

  for (let y = 0; y < state.rows; y++) {
    for (let x = 0; x < state.cols; x++) {
      const p = tileToScreen(x, y);
      drawTile(p.x, p.y);
    }
  }

  drawPlayer();

  ctx.restore();
}

function drawTile(x, y) {
  const w = state.tileW;
  const h = state.tileH;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + w / 2, y + h / 2);
  ctx.lineTo(x, y + h);
  ctx.lineTo(x - w / 2, y + h / 2);
  ctx.closePath();
  ctx.stroke();
}

function drawPlayer() {
  const p = tileToScreen(state.player.x, state.player.y);
  const img = playerImage;

  if (state.spriteLoaded) {
    const px = p.x - img.width / 2;
    const py = p.y - img.height + state.tileH / 2;
    ctx.drawImage(img, px, py);
  } else {
    ctx.fillStyle = '#ff6';
    ctx.beginPath();
    ctx.arc(p.x, p.y - 20, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ----------------- MOVIMIENTO LIBRE DIAGONAL -----------------
window.addEventListener('keydown', (e) => { state.keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', (e) => { state.keys[e.key.toLowerCase()] = false; });

function updatePlayerMovement(dt) {
  let dx = 0, dy = 0;

  // Movimiento diagonal mapeado a la grilla
  if (state.keys['arrowup'] || state.keys['w']) { dx -= 1; dy -= 1; }    // arriba
  if (state.keys['arrowdown'] || state.keys['s']) { dx += 1; dy += 1; }  // abajo
  if (state.keys['arrowleft'] || state.keys['a']) { dx -= 1; dy += 1; }  // izquierda
  if (state.keys['arrowright'] || state.keys['d']) { dx += 1; dy -= 1; } // derecha

  // Normalizar movimiento diagonal
  if (dx !== 0 && dy !== 0) {
    dx *= Math.SQRT1_2;
    dy *= Math.SQRT1_2;
  }

  // Aplicar velocidad
  state.player.x += dx * CONFIG.playerSpeed * dt;
  state.player.y += dy * CONFIG.playerSpeed * dt;

  // Limites
  state.player.x = clamp(state.player.x, 0, state.cols - 1);
  state.player.y = clamp(state.player.y, 0, state.rows - 1);

  // Snap suave a la grilla si no hay teclas presionadas
  if (dx === 0 && dy === 0) {
    state.player.x = lerp(state.player.x, Math.round(state.player.x), CONFIG.snapSpeed * dt);
    state.player.y = lerp(state.player.y, Math.round(state.player.y), CONFIG.snapSpeed * dt);
  }
}

// ----------------- CÁMARA -----------------
function updateCameraTarget() {
  const p = tileToScreen(state.player.x, state.player.y);
  state.cameraTarget.x = p.x;
  state.cameraTarget.y = p.y;
}

// ----------------- LOOP -----------------
let lastTime = 0;
function loop(ts) {
  const dt = (ts - lastTime) / 1000; // delta en segundos
  lastTime = ts;

  updatePlayerMovement(dt);

  state.camera.x = lerp(state.camera.x, state.cameraTarget.x, CONFIG.cameraLag);
  state.camera.y = lerp(state.camera.y, state.cameraTarget.y, CONFIG.cameraLag);

  clear();
  drawIsometricGrid();

  requestAnimationFrame(loop);
}

// ----------------- REDIMENSIÓN -----------------
function resizeCanvas() {
  DPR = window.devicePixelRatio || 1;
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}

// ----------------- INICIALIZACIÓN -----------------
function init() {
  resizeCanvas();
  updateCameraTarget();
  state.camera.x = state.cameraTarget.x;
  state.camera.y = state.cameraTarget.y;

  window.addEventListener('resize', resizeCanvas);
  canvas.addEventListener('click', () => canvas.focus());

  requestAnimationFrame(loop);
}

init();

//camera.js
// scripts/camera.js
import { lerp } from './config.js';

export class Camera {
  constructor(player, offsetX = 0, offsetY = 0) {
    this.player = player;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    this.x = 0;
    this.y = 0;
    this.targetX = 0;
    this.targetY = 0;

    this.dragging = false;
    this.dragStart = { x: 0, y: 0 };
    this.startPos = { x: 0, y: 0 };
  }

  startDrag(x, y) {
    this.dragging = true;
    this.dragStart = { x, y };
    this.startPos = { x: this.x, y: this.y };
  }

  drag(x, y) {
    if (!this.dragging) return;
    const dx = x - this.dragStart.x;
    const dy = y - this.dragStart.y;
    this.x = this.startPos.x - dx;
    this.y = this.startPos.y - dy;
  }

  endDrag() {
    this.dragging = false;
  }

  update(dt, grid, cameraLag, isLocked = true) {
    const p = grid.tileToScreen(this.player.x, this.player.y);
    this.targetX = p.x + this.offsetX;
    this.targetY = p.y + this.offsetY;

    if (!this.dragging) {
      if (isLocked) {
        // Cámara sigue al jugador suavemente
        this.x = lerp(this.x, this.targetX, cameraLag);
        this.y = lerp(this.y, this.targetY, cameraLag);
      }
      // Si no está bloqueada y no arrastrando, queda donde está
    }
    // Si arrastrando, la posición ya se actualiza en drag()
  }
}


//config.js

// scripts/Config.js
export const CONFIG = {
  cols: 30,
  rows: 30,
  tileWidth: 64,
  tileHeight: 32,
  scale: 1.0,
  backgroundColor: '#2b3440',
  playerSpritePath: 'assets/sprites/player.png',
  initialPlayer: { x: 10, y: 10 },
  cameraLag: 0.12,
  playerSpeed: 5,   // tiles por segundo
  snapSpeed: 10     // velocidad de snap a grilla
};

export function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
export function lerp(a, b, t) { return a + (b - a) * t; }


//generateSprites.js

// node scripts/generateSprites.js

const fs = require('fs');
const path = require('path');

const spriteFolders = [
  { dir: './assets/sprites/floor', category: 'floor' },
  { dir: './assets/sprites/wall', category: 'wall' },
  { dir: './assets/sprites/object', category: 'object' }
];

const sprites = [];

spriteFolders.forEach(folder => {
  const files = fs.readdirSync(folder.dir);
  files.forEach(file => {
    const match = file.match(/(.+?)_(\d+)x(\d+)_\d+\.png$/);
    if (match) {
      const [_, name, width, height] = match;
      sprites.push({
        path: path.join(folder.dir, file).replace(/\\/g, '/'),
        name,
        category: folder.category,
        width: Number(width),
        height: Number(height)
      });
    }
  });
});

fs.writeFileSync('./assets/sprites.json', JSON.stringify(sprites, null, 2));
console.log('sprites.json generado correctamente');


//grid.js

import { CONFIG } from './config.js';

export class Grid {
  constructor(cols = CONFIG.cols, rows = CONFIG.rows, tileW = CONFIG.tileWidth, tileH = CONFIG.tileHeight) {
    this.cols = cols;
    this.rows = rows;
    this.tileW = tileW;
    this.tileH = tileH;
    // Cada celda ahora es un objeto con posibles capas
    this.tiles = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => ({ floor: null, wall: null, object: null }))
    );
  }

  tileToScreen(x, y) {
    return { x: (x - y) * (this.tileW / 2), y: (x + y) * (this.tileH / 2) };
  }

  screenToTile(sx, sy) {
    const x = (sx / (this.tileW / 2) + sy / (this.tileH / 2)) / 2;
    const y = (sy / (this.tileH / 2) - sx / (this.tileW / 2)) / 2;
    const tx = Math.floor(x);
    const ty = Math.floor(y);
    if (tx < 0 || ty < 0 || tx >= this.cols || ty >= this.rows) return null;
    return { x: tx, y: ty };
  }

  setTileSprite(x, y, sprite) {
    if (!sprite || !sprite.category) return;
    this.tiles[y][x][sprite.category] = sprite;
  }

  clearTile(x, y, category = null) {
    if (category) this.tiles[y][x][category] = null;
    else this.tiles[y][x] = { floor: null, wall: null, object: null };
  }

  draw(ctx, camera) {
    ctx.save();
    ctx.translate(ctx.canvas.width / 2 - camera.x, ctx.canvas.height / 4 - camera.y);

    for (let y = 0; y < this.rows; y++) {
      for (let x = 0; x < this.cols; x++) {
        const p = this.tileToScreen(x, y);
        const cell = this.tiles[y][x];

        // Dibujar grid base
        if (!cell.floor && !cell.wall && !cell.object) {
          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x + this.tileW / 2, p.y + this.tileH / 2);
          ctx.lineTo(p.x, p.y + this.tileH);
          ctx.lineTo(p.x - this.tileW / 2, p.y + this.tileH / 2);
          ctx.closePath();
          ctx.stroke();
        }

        // Dibujar capas en orden: floor → wall → object
        ['floor', 'wall', 'object'].forEach(layer => {
          const tile = cell[layer];
          if (tile && tile.img && tile.loaded) {
            ctx.drawImage(
              tile.img,
              p.x - this.tileW / 2,
              p.y - this.tileH * (tile.height - 1),
              this.tileW * tile.width,
              this.tileH * tile.height
            );
          }
        });
      }
    }

    ctx.restore();
  }
}


//hud.js

// scripts/hud.js
export class HUD {
  constructor(containerId = 'hud') {
    this.container = document.getElementById(containerId);
    this.mode = 'camera'; // 'camera' o 'sprite'
    this.cameraLocked = true;
    this.selectedCategory = 'floor';
    this.selectedSprite = null;
    this.sprites = {}; // path -> { img, loaded, width, height, name, category }

    this.initHUD();
    this.loadSpritesJSON();
  }

  initHUD() {
    // --- Botón de modo ---
    this.modeBtn = document.createElement('button');
    this.modeBtn.textContent = 'Modo: Cámara';
    this.container.appendChild(this.modeBtn);
    this.modeBtn.addEventListener('click', () => {
      this.setMode(this.mode === 'camera' ? 'sprite' : 'camera');
    });

    // --- Checkbox de bloqueo de cámara ---
    this.lockCheckbox = document.createElement('input');
    this.lockCheckbox.type = 'checkbox';
    this.lockCheckbox.checked = true;
    this.lockLabel = document.createElement('label');
    this.lockLabel.textContent = 'Bloquear cámara';
    this.lockLabel.prepend(this.lockCheckbox);
    this.container.appendChild(this.lockLabel);

    this.lockCheckbox.addEventListener('change', () => {
      this.cameraLocked = this.lockCheckbox.checked;
    });

    // --- Selector de categoría (Piso, Pared, Objeto) ---
    this.categorySelect = document.createElement('select');
    ['floor', 'wall', 'object'].forEach(c => {
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c.charAt(0).toUpperCase() + c.slice(1);
      this.categorySelect.appendChild(opt);
    });
    this.container.appendChild(this.categorySelect);

    this.categorySelect.addEventListener('change', e => {
      this.selectedCategory = e.target.value;
      this.updateSpriteDropdown();
    });

    // --- Dropdown de sprites ---
    this.spriteDropdown = document.createElement('select');
    this.container.appendChild(this.spriteDropdown);
    this.spriteDropdown.addEventListener('change', e => {
      this.selectedSprite = e.target.value;
    });

    // --- Inicializamos visibilidad ---
    this.updateHUDVisibility();
  }

  setMode(mode) {
    this.mode = mode;
    this.modeBtn.textContent = mode === 'camera' ? 'Modo: Cámara' : 'Modo: Sprite';
    this.updateHUDVisibility();
  }

  updateHUDVisibility() {
    if (this.mode === 'camera') {
      this.lockLabel.style.display = 'inline-block';
      this.categorySelect.style.display = 'none';
      this.spriteDropdown.style.display = 'none';
    } else {
      this.lockLabel.style.display = 'none';
      this.categorySelect.style.display = 'inline-block';
      this.spriteDropdown.style.display = 'inline-block';
      this.updateSpriteDropdown();
    }
  }

  isCameraMode() { return this.mode === 'camera'; }
  isCameraLocked() { return this.cameraLocked; }
  getSelectedSprite() { return this.selectedSprite; }

  // --- Cargar sprites desde JSON ---
  loadSpritesJSON() {
    fetch('assets/sprites.json')
      .then(res => res.json())
      .then(data => {
        data.forEach(obj => {
          const img = new Image();
          const spriteObj = {
            img,
            loaded: false,
            width: obj.width,
            height: obj.height,
            name: obj.name,
            category: obj.category
          };
          img.onload = () => spriteObj.loaded = true;
          img.onerror = () => console.warn('No se pudo cargar:', obj.path);
          img.src = obj.path;
          this.sprites[obj.path] = spriteObj;
        });
        // Actualizar dropdown de sprites al final
        this.updateSpriteDropdown();
      })
      .catch(err => console.error('Error cargando sprites.json:', err));
  }

  updateSpriteDropdown() {
    this.spriteDropdown.innerHTML = '';
    Object.entries(this.sprites).forEach(([path, data]) => {
      if (data.category === this.selectedCategory) {
        const opt = document.createElement('option');
        opt.value = path;
        opt.textContent = data.name + ` (${data.width}x${data.height})`;
        this.spriteDropdown.appendChild(opt);
      }
    });
    this.selectedSprite = this.spriteDropdown.value || null;
  }

  isSpriteLoaded(path) {
    return path && this.sprites[path] && this.sprites[path].loaded;
  }

  getSpriteData(path) {
    if (this.sprites[path]) return this.sprites[path];
    return null;
  }
}


//input.js

// scripts/Input.js
export function initInput(player) {
  window.addEventListener('keydown', (e) => player.handleKeyDown(e.key));
  window.addEventListener('keyup', (e) => player.handleKeyUp(e.key));
}


//main.js

// scripts/main.js
import { CONFIG, lerp } from './config.js';
import { Grid } from './grid.js';
import { Player } from './player.js';
import { Camera } from './camera.js';
import { initInput } from './input.js';
import { HUD } from './hud.js';

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;

// --- Instancias ---
const grid = new Grid();
const player = new Player(grid);
const camera = new Camera(player, 0, -150);
initInput(player);
const hud = new HUD();

// --- Imagen de fondo ---
const bgImage = new Image();
bgImage.src = 'assets/backgrounds/bg.png';
let bgLoaded = false;
bgImage.onload = () => bgLoaded = true;

// --- Resize canvas ---
function resizeCanvas() {
    DPR = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w * DPR);
    canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    const p = grid.tileToScreen(player.x, player.y);
    camera.x = p.x + camera.offsetX;
    camera.y = p.y + camera.offsetY;
}
window.addEventListener('resize', resizeCanvas);
canvas.addEventListener('click', () => canvas.focus());
resizeCanvas();

// --- Desactivar menú contextual ---
canvas.addEventListener('contextmenu', e => e.preventDefault());

// --- Drag y pintado ---
let isMouseDown = false;
let mouseButton = 0;
let mousePos = null;

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
    };
}

// --- Helper: tile de base bajo el cursor ---
function getBaseTileUnderCursor(pos) {
    const baseTile = grid.screenToTile(
        pos.x + camera.x - canvas.width / 2,
        pos.y + camera.y - canvas.height / 4
    );
    if (!baseTile) return null;
    return { x: baseTile.x, y: baseTile.y };
}

// --- Helper: posición de dibujado considerando altura del sprite ---
function getDrawPosition(baseTile, sprite) {
    const pos = grid.tileToScreen(baseTile.x, baseTile.y);
    const drawX = pos.x - (grid.tileW * sprite.width) / 2;
    const drawY = pos.y - grid.tileH * (sprite.height - 1); // base sobre el tile
    return { x: drawX, y: drawY };
}

// --- Colocar o borrar sprite ---
function handlePaint(pos, button) {
    const spritePath = hud.getSelectedSprite();
    const spriteData = hud.getSpriteData(spritePath);
    if (!spriteData || !spriteData.loaded) return;

    const baseTile = getBaseTileUnderCursor(pos);
    if (!baseTile) return;

    if (button === 0) {
        grid.setTileSprite(baseTile.x, baseTile.y, spriteData, spriteData.layer);
    } else if (button === 2) {
        grid.clearTile(baseTile.x, baseTile.y, spriteData.layer);
    }
}

canvas.addEventListener('mousedown', (e) => {
    mousePos = getMousePos(e);
    isMouseDown = true;
    mouseButton = e.button;

    if (hud.isCameraMode()) {
        camera.startDrag(mousePos.x, mousePos.y);
    } else {
        handlePaint(mousePos, e.button);
    }
});

canvas.addEventListener('mousemove', (e) => {
    mousePos = getMousePos(e);

    if (!isMouseDown) return;

    if (hud.isCameraMode()) camera.drag(mousePos.x, mousePos.y);
    else handlePaint(mousePos, mouseButton);
});

canvas.addEventListener('mouseup', () => {
    isMouseDown = false;
    if (hud.isCameraMode()) camera.endDrag();
});
canvas.addEventListener('mouseleave', () => {
    if (isMouseDown) {
        isMouseDown = false;
        if (hud.isCameraMode()) camera.endDrag();
    }
});

// --- Loop principal ---
let lastTime = 0;
function loop(ts) {
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;

    camera.update(dt, grid, CONFIG.cameraLag, hud.isCameraLocked());
    player.update(dt);

    ctx.fillStyle = CONFIG.backgroundColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (bgLoaded) ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);

    grid.draw(ctx, camera);

    // --- Preview transparente del sprite seleccionado ---
    if (hud.mode === 'sprite' && hud.getSelectedSprite() && mousePos) {
        const spriteData = hud.getSpriteData(hud.getSelectedSprite());
        if (spriteData && spriteData.loaded) {
            const baseTile = getBaseTileUnderCursor(mousePos);
            if (baseTile) {
                // Calculamos la posición en pantalla como en Grid.draw
                const p = grid.tileToScreen(baseTile.x, baseTile.y);
                const drawX = p.x - grid.tileW / 2; // centrado horizontal
                const drawY = p.y - grid.tileH * (spriteData.height - 1); // base en el tile

                ctx.save();
                ctx.translate(ctx.canvas.width / 2 - camera.x, ctx.canvas.height / 4 - camera.y);
                ctx.globalAlpha = 0.5;
                ctx.drawImage(spriteData.img, drawX, drawY, grid.tileW * spriteData.width, grid.tileH * spriteData.height);
                ctx.restore();
            }
        }
    }

    player.draw(ctx, grid, camera);

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);


//player.js

// scripts/Player.js
import { CONFIG, clamp, lerp } from './config.js';

export class Player {
  constructor(grid) {
    this.grid = grid;
    this.x = CONFIG.initialPlayer.x;
    this.y = CONFIG.initialPlayer.y;
    this.keys = {};
    this.sprite = new Image();
    this.sprite.src = CONFIG.playerSpritePath;
    this.spriteLoaded = false;
    this.sprite.onload = () => this.spriteLoaded = true;
  }

  handleKeyDown(key) { this.keys[key.toLowerCase()] = true; }
  handleKeyUp(key) { this.keys[key.toLowerCase()] = false; }

  update(dt) {
    let dx = 0, dy = 0;
    // Movimiento diagonal
    if (this.keys['arrowup'] || this.keys['w']) { dx -= 1; dy -= 1; }
    if (this.keys['arrowdown'] || this.keys['s']) { dx += 1; dy += 1; }
    if (this.keys['arrowleft'] || this.keys['a']) { dx -= 1; dy += 1; }
    if (this.keys['arrowright'] || this.keys['d']) { dx += 1; dy -= 1; }

    if (dx !== 0 && dy !== 0) { dx *= Math.SQRT1_2; dy *= Math.SQRT1_2; }

    this.x += dx * CONFIG.playerSpeed * dt;
    this.y += dy * CONFIG.playerSpeed * dt;

    this.x = clamp(this.x, 0, CONFIG.cols - 1);
    this.y = clamp(this.y, 0, CONFIG.rows - 1);

    if (dx === 0 && dy === 0) {
      this.x = lerp(this.x, Math.round(this.x), CONFIG.snapSpeed * dt);
      this.y = lerp(this.y, Math.round(this.y), CONFIG.snapSpeed * dt);
    }
  }

  draw(ctx, grid, camera) {
    const p = grid.tileToScreen(this.x, this.y);
    ctx.save();
    ctx.translate(ctx.canvas.width / 2 - camera.x, ctx.canvas.height / 4 - camera.y);
    ctx.scale(CONFIG.scale, CONFIG.scale);

    if (this.spriteLoaded) {
      const px = p.x - this.sprite.width / 2;
      const py = p.y - this.sprite.height + grid.tileH / 2;
      ctx.drawImage(this.sprite, px, py);
    } else {
      ctx.fillStyle = '#ff6';
      ctx.beginPath();
      ctx.arc(p.x, p.y - 20, 10, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }
}


//index.html

<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Mundo Catita - Base</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Contenedor principal -->
<div id="game-root">
<canvas id="game-canvas" tabindex="0" aria-label="Canvas del juego Mundo Catita"></canvas>
<!-- Panel mínimo de depuración (opcional) -->

<div id="hud">
    <div id="info">Mundo Catita — v0.1</div>

</div>


<!-- Scripts del juego -->
<script type="module" src="scripts/main.js"></script>

<!-- Lugar para scripts futuros en /scripts -->
<!-- <script src="scripts/otraLogica.js"></script> -->
</body>
</html>

//styles.css

:root{
--bg: #0f1720; /* color base del contenedor */
--hud-bg: rgba(0,0,0,0.3);
--hud-fg: #e6eef8;
}
html,body{
height:100%;
margin:0;
}
body{
background:var(--bg);
font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
-webkit-font-smoothing:antialiased;
-moz-osx-font-smoothing:grayscale;
}
#game-root{
position:fixed;
inset:0; /* ocupa toda la pantalla */
overflow:hidden;
}
#game-canvas{
display:block;
width:100%;
height:100%;
outline:none; /* para evitar borde cuando tiene foco */
image-rendering: optimizeSpeed; /* para píxeles limpios si usás sprites pequeños */
}
#hud{
position:fixed;
left:12px;
top:12px;
background:var(--hud-bg);
color:var(--hud-fg);
padding:8px 12px;
border-radius:8px;
font-size:13px;
z-index:10;
}


/* Pequeños estilos responsivos */
@media (max-width:480px){
#hud{ font-size:12px; padding:6px 8px }
}

#hud {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.6);
  color: white;
  padding: 10px;
  border-radius: 8px;
  font-family: sans-serif;
}
#hud select {
  margin: 0 5px;
}


canvas:active { cursor: grab; }